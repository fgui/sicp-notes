* 1.2 Procedures and the Processes They Generate

[hl] To become experts, we must learn to visualize the
processes generated by various types of procedures

[hl] A procedure is a pattern for the local evolution of a computational
process.

[hl] common “shapes” for processes generated by simple procedures

** 1.2.1 Linear Recursion and Iteration

*** Linear Recursion

(defn factorial [n]
  (if (zero? n)
      1
      (* n (factorial (- n 1)))))

[hl] The substitution model reveals a shape of
expansion followed by contraction

[hl] Expansion builds up a chain of deferred operations

[hl] Contraction occurs as the operations as performed

[hl] This type of process, characterized by a chain of
deferred operations, is called a *recursive process*.

[hl] Process need to keep track of information. The amount
of information grows linearly with n (proportional to n)

[my understanding]
Linear -> to compute n! we need n steps (time)
Recursive -> to compute n! we need n space (memory)

*** Linear Iterative

(defn factorial [n]
   (let [fact-iter
         (fn [acc c]
            (if (zero? c) acc
              (recur (* c acc) (DEC c))))]
        (fact-iter 1 c)))

[hl] process does not grow and shrink
[hl] At each step, all we need to keep track of, for any n, are the current values of
a few variables. The number of variables that we need to keep track stays the
same.
[hl] Such a process is called a *iterative process*.

[hl] An iterative process is one whose state can be summarized by a fixed number
of state variables , together with a fixed rule
that describes how the state variables should be updated as the process
moves from state to state

[my understanding]
Linear -> to compute n! we need n steps (time)
Iterative -> to compute n! we need 1 space (memory)


*** Tail-recursive
[hl - rw]
An interpreter/compiles tail-recursive implementation executes an
 iterative process in constant space, even if the iterative process
 is described by a recursive procedure

*** exercise 1.9

(define (+ a b)
(if (= a 0) b (inc (+ (dec a) b))))

(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7)
(inc 8)
9

(define (+ a b)
(if (= a 0) b (+ (dec a) (inc b))))

(+ 4 5)
(+ 3 6)
(+ 2 8)
(+ 1 9)
(+ 0 9)
9


*** exercise 1.10
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1) (A x (- y 1))))))

(A 1 10)
(A 0 (A 1 9))
(A 0 (A 0 (A 1 8))
(A 0 (A 0 .... (A 0 1))
(A 0 (A 0 ... (A 0 2))
(A 0 (A 0 .. (A 0 4)
....
2^10 = 1024

(A 2 4)
(A 1 (A 2 3))
(A 1 (A 1 (A 2 2))
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 (A 0 (A 1 1))))
(A 1 (A 1 (A 0 2)))
(A 1 (A 1 4))
(A 1 (A 0 (A 1 3)))
(A 1 (A 0 (A 0 (A 1 2))))
(A 1 (A 0 (A 0 (A 0 (A 1 1)))))
(A 1 (A 0 (A 0 (A 0 2))))
(A 1 (A 0 (A 0 4)))
(A 1 (A 0 8))
(A 1 16)
...
2^16 = 65536

(A 3 3)
(A 2 (A 3 2))
(A 2 (A 2 (A 3 1)))
(A 2 (A 2 2))
(A 2 (A 1 (A 2 1))
(A 2 (A 1 2))
(A 2 (A 0 (A 1 1)))
(A 2 (A 0 2))
(A 2 4)
...
2^16 = 65536

code/clj/scr/sicp/ex1_10.clj

(define (f n) (A 0 n))   => 2*n
(define (g n) (A 1 n))   => 2^n
(define (h n) (A 2 n))   => 2^(2^n)
(define (k n) (* 5 n n)) => 5*(n^2)

*** 1.2.2 Tree Recursion

(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1)) (fib (- n 2))))))

(fib 4)
(+ (fib 2) (fib 3))
(+ (+ (fib 0) (fib 1)) (+ (fib 1) (fib 2)))
(+ (+ 0 1) (+ 1 (+ (fib 0) (fib 1))))
(+ 1 (+ 1 (+ 0 1)))
(+ 1 (+ 1 1))
(+ 1 2)
3

[hl] The process uses a number of steps that grows exponentially with
the input. On the other hand, the space required grows only linearly
with the input
[hl] The number of steps required by a tree-recursive process will be
proportional to the number of nodes in the tree

[my understanding]
Tree -> to compute n! we need exponential e^n steps (time)
Recursive -> to compute n! we need n space (memory)

*** exercise 1.11
code/clj/src/sicp/ex1_11

*** exercise 1.12 Pascal's triangle
code/clj/src/sicp/ex1_12

*** exercise 1.13
[maths]
0 1 1 2 3 5 8 13 21 34 55 89

(defn fib[n] (+ (fib (- n 2) (fib (- n 1)))))

fib(n) = (int) phi^n/root(5)

phi = 1 + root(5) / 2

*** 1.2.3 Orders of Growth
