* 1.2 Procedures and the Processes They Generate

[hl] To become experts, we must learn to visualize the
processes generated by various types of procedures

[hl] A procedure is a pattern for the local evolution of a computational
process.

[hl] common “shapes” for processes generated by simple procedures

** 1.2.1 Linear Recursion and Iteration

*** Linear Recursion
#+BEGIN_SRC

(defn factorial [n]
  (if (zero? n)
      1
      (* n (factorial (- n 1)))))

#+END_SRC

[hl] The substitution model reveals a shape of
expansion followed by contraction

[hl] Expansion builds up a chain of deferred operations

[hl] Contraction occurs as the operations as performed

[hl] This type of process, characterized by a chain of
deferred operations, is called a *recursive process*.

[hl] Process need to keep track of information. The amount
of information grows linearly with n (proportional to n)

[my understanding]
Linear -> to compute n! we need n steps (time)
Recursive -> to compute n! we need n space (memory)

*** Linear Iterative

#+BEGIN_SRC

(defn factorial [n]
   (let [fact-iter
         (fn [acc c]
            (if (zero? c) acc
              (recur (* c acc) (DEC c))))]
        (fact-iter 1 c)))

#+END_SRC

[hl] process does not grow and shrink
[hl] At each step, all we need to keep track of, for any n, are the current values of
a few variables. The number of variables that we need to keep track stays the
same.
[hl] Such a process is called a *iterative process*.

[hl] An iterative process is one whose state can be summarized by a fixed number
of state variables , together with a fixed rule
that describes how the state variables should be updated as the process
moves from state to state

[my understanding]
Linear -> to compute n! we need n steps (time)
Iterative -> to compute n! we need 1 space (memory)


*** Tail-recursive
[hl - rw]
An interpreter/compiles tail-recursive implementation executes an
 iterative process in constant space, even if the iterative process
 is described by a recursive procedure

*** exercise 1.9
#+BEGIN_SRC

(define (+ a b)
(if (= a 0) b (inc (+ (dec a) b))))

(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7)
(inc 8)
9

(define (+ a b)
(if (= a 0) b (+ (dec a) (inc b))))

(+ 4 5)
(+ 3 6)
(+ 2 8)
(+ 1 9)
(+ 0 9)
9

#+END_SRC

*** exercise 1.10

#+BEGIN_SRC

(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1) (A x (- y 1))))))

(A 1 10)
(A 0 (A 1 9))
(A 0 (A 0 (A 1 8))
(A 0 (A 0 .... (A 0 1))
(A 0 (A 0 ... (A 0 2))
(A 0 (A 0 .. (A 0 4)
....
2^10 = 1024

(A 2 4)
(A 1 (A 2 3))
(A 1 (A 1 (A 2 2))
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 (A 0 (A 1 1))))
(A 1 (A 1 (A 0 2)))
(A 1 (A 1 4))
(A 1 (A 0 (A 1 3)))
(A 1 (A 0 (A 0 (A 1 2))))
(A 1 (A 0 (A 0 (A 0 (A 1 1)))))
(A 1 (A 0 (A 0 (A 0 2))))
(A 1 (A 0 (A 0 4)))
(A 1 (A 0 8))
(A 1 16)
...
2^16 = 65536

(A 3 3)
(A 2 (A 3 2))
(A 2 (A 2 (A 3 1)))
(A 2 (A 2 2))
(A 2 (A 1 (A 2 1))
(A 2 (A 1 2))
(A 2 (A 0 (A 1 1)))
(A 2 (A 0 2))
(A 2 4)
...
2^16 = 65536

code/clj/scr/sicp/ex1_10.clj

(define (f n) (A 0 n))   => 2*n
(define (g n) (A 1 n))   => 2^n
(define (h n) (A 2 n))   => 2^(2^n)
(define (k n) (* 5 n n)) => 5*(n^2)

#+END_SRC

*** 1.2.2 Tree Recursion
#+BEGIN_SRC

(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1)) (fib (- n 2))))))

(fib 4)
(+ (fib 2) (fib 3))
(+ (+ (fib 0) (fib 1)) (+ (fib 1) (fib 2)))
(+ (+ 0 1) (+ 1 (+ (fib 0) (fib 1))))
(+ 1 (+ 1 (+ 0 1)))
(+ 1 (+ 1 1))
(+ 1 2)
3

#+END_SRC

[hl] The process uses a number of steps that grows exponentially with
the input. On the other hand, the space required grows only linearly
with the input
[hl] The number of steps required by a tree-recursive process will be
proportional to the number of nodes in the tree

[my understanding]
Tree -> to compute n! we need exponential e^n steps (time)
Recursive -> to compute n! we need n space (memory)

*** exercise 1.11
write function recursive and then iterative
[[code/clj/src/sicp/ex1_11.clj]]

*** exercise 1.12 Pascal's triangle
calculate position Pascal's triangle.
[[code/clj/src/sicp/ex1_12.clj]]

*** exercise 1.13 [todo]
#+BEGIN_SRC
Prove:
fib(n) = (int) phi^n/root(5)
phi = 1 + root(5) / 2

0 1 1 2 3 5 8 13 21 34 55 89

(defn fib[n] (+ (fib (- n 2) (fib (- n 1)))))

#+END_SRC

*** 1.2.3 Orders of Growth (O)
O (theta)
R(n) resources required

[hl] R(n) might measure the number of internal storage registers
used, the number of elementary machine operations performed, and so
on.

Lineal recursive : Space O(n) Steps O(n)
Lineal iterative : Space O(1) Steps O(n)
Tree recursive : Space O(n) Steps O(phi^n)

*** exercise 1.14

#+BEGIN_SRC

(define (count-change amount)
   (cc amount 5))
(define (cc amount kinds-of-coins)
   (cond ((= amount 0) 1)
         ((or (< amount 0) (= kinds-of-coins 0)) 0)
         (else (+ (cc amount(- kinds-of-coins 1))
                  (cc (- amount (first-denomination kinds-of-coins)) kinds-of-coins)))))

(define (first-denomination kinds-of-coins)
(cond ((= kinds-of-coins 1) 1)
((= kinds-of-coins 2) 5)
((= kinds-of-coins 3) 10)
((= kinds-of-coins 4) 25)
((= kinds-of-coins 5) 50)))

tree:

                  (count-change 11)
                               (cc 11 5)
                 (cc 11 4)   <-         ->   (cc -39 5)
         (cc 11 3)<-    -> (cc -14 4)             0
  (cc 11 2)<-  ->(cc 1 3)        0

branch:
(cc 1 3)
<- (cc 1 2)
<- (cc 1 1)
-> (cc 0 1)
1

branch:
(cc 11 2)
(cc 11 1)<- ->(cc 6 2)

branch:
(cc 6 2)
(cc 6 1)<- ->(cc 1 1)
...          ...
1            1

branch:
(cc 11 1)
(cc 10 1)
(cc 9 1)
(cc 8 1)
(cc 7 1)
(cc 6 1)
...
(cc 1 1)
(cc 0 1)
1
#+END_SRC


*** exercise 1.15

#+BEGIN_SRC scheme-mode -n
(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine angle)
    (if (not (> (abs angle) 0.1))
         angle
         (p (sine (/ angle 3.0)))))
#+END_SRC
#+BEGIN_SRC
a)
(sine 12.5)
(p (sine 4.16))
(p (p (sine 1.39)))
(p (p (p (sine 0.46))))
(p (p (p (p (sine 0.15)))))
(p (p (p (p (p (sine 0.05))))))
(p (p (p (p (p 0.05)))))

12.5 / (3^5) = 0.049
5 times

b)
spaces recursive O(n)

steps O(log n)
(12.5 => 5) (1000 => 10) (10000 => 12) ...
first value steps => n / (3 ^ steps) < 0.01
#+END_SRC

*** 1.2.4 Exponentiation
#+BEGIN_SRC
b^n = b * b^(n-1)

b^2 = b * b
b^4 = b^2 * b^2
...
#+END_SRC

#+BEGIN_SRC scheme-mode -n
(defn fast-expt [b n]
  (cond (= n 0)
        1
        (even? n)
        (square (fast-expt b (/ n 2)))
        :else
        (* b (fast-expt b (dec n)))))

steps O(log n)
space O(1)
#+END_SRC

*** exercise 1.16 [todo]
*** exercise 1.17
#+BEGIN_SRC
(define (* a b)
  (if (= b 0)
      0
#+END_SRC
Linear in b O(n)

use doble and halve

*** exercise 1.18 [todo]
*** exercise 1.19 [todo]

*** 1.2.5 Greatest Common Divisor
The greatest common divisor (gcd) of two integers a and b is defined to
be the largest integer that divides both a and b with no remainder.

Euclid's Algorithm:
(gcd a b) is the same as (gcd b r) where r is the reminder or (/ a b)

#+BEGIN_SRC

(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))

#+END_SRC

O(log n) & iterative

*** exercise 1.20 [todo]
- normal-order of evaluation
- applicative-order of evaluation


**** applicative-order
#+BEGIN_SRC

(gcd 206 40)
(gcd 40 (remainder 206 40))
(gcd 40 6)
(gcd 6 (remainder 40 6))
(gcd 6 4)
(gcd 4 (remainder 6 4))
(gcd 4 2)
(gcd 2 (reminder 4 2))
(gcd 2 0)
2
[4 remainders]

#+END_SRC

**** normal-order ?? [todo]
what happens with *if*?
#+BEGIN_SRC

(gcd 206 40)
(gcd 40 (remainder 206 40))
(gcd (remainder 206 40) (remainder 40 (remainder 206 40)))
...

#+END_SRC
*** 1.2.6 Example: Testing for Primality

O(root(n)) -> divisor btw 1 and root (n)

O(log n) -> probabilistic algorithm (Fermat test)

Probabilistic methods/algorithms

** 1.3 Formulating Abstractions with Higher-Order Procedures
