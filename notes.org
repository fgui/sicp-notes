* 1 Building Abstractions with Procedures
** 1.1 The Elements of Programming
*** 1.1.1 Expressions
*** 1.1.2 Naming and the Environment
*** 1.1.3 Evaluating Combinations
*** 1.1.4 Compound Procedures
*** 1.1.5 The Substitution Model for Procedure Application
**** Applicative order vs normal order
- applicative order : interpreter first evaluates the operator and operands and then applies
the resulting procedure to the resulting arguments
- normal order : first substitute operand expressions for parameters until it obtained an
expression involving only primitive operators, and would then perform
the evaluation
*** 1.1.6 Conditional Expressions and Predicates
**** exercise 1.5
#+BEGIN_SRC scheme
(define (p) (p))
(define (test x y)
   (if (= x 0) 0 y))

(test 0 (p))

;; applicative-order
(test 0 (p))
p is evaluated -> infinite recursion

;; normal-order
(test 0 (p))
(if (= 0 0) 0 (p))
(if true 0 (p))
0
p never requires evaluation
...
;; never ends.
#+END_SRC

*** 1.1.7 Example: Square Roots by Newton’s Method
*** 1.1.8 Procedures as Black-Box Abstractions
**** Local names
**** Internal definitions and block structure
** 1.2 Procedures and the Processes They Generate

#+BEGIN_QUOTE
To become experts, we must learn to visualize the
processes generated by various types of procedures
#+END_QUOTE

#+BEGIN_QUOTE
A procedure is a pattern for the local evolution of a computational
process.
#+END_QUOTE

#+BEGIN_QUOTE
common “shapes” for processes generated by simple procedures
#+END_QUOTE

*** 1.2.1 Linear Recursion and Iteration

**** Linear Recursion
#+BEGIN_SRC clojure
(defn factorial [n]
  (if (zero? n)
      1
      (* n (factorial (- n 1)))))
#+END_SRC

#+BEGIN_QUOTE
The substitution model reveals a shape of
expansion followed by contraction
#+END_QUOTE

#+BEGIN_QUOTE
Expansion builds up a chain of deferred operations
#+END_QUOTE

#+BEGIN_QUOTE
Contraction occurs as the operations as performed
#+END_QUOTE

#+BEGIN_QUOTE
This type of process, characterized by a chain of
deferred operations, is called a *recursive process*.
#+END_QUOTE

#+BEGIN_QUOTE
Process need to keep track of information. The amount
of information grows linearly with n (proportional to n)
#+END_QUOTE

[my understanding]
- Linear -> to compute n! we need n steps (time)
- Recursive -> to compute n! we need n space (memory)

**** Linear Iterative

#+BEGIN_SRC clojure
(defn factorial [n]
   (let [fact-iter
         (fn [acc c]
            (if (zero? c) acc
              (recur (* c acc) (DEC c))))]
        (fact-iter 1 c)))
#+END_SRC

#+BEGIN_QUOTE
process does not grow and shrink
#+END_QUOTE

#+BEGIN_QUOTE
At each step, all we need to keep track of, for any n, are the current values of
a few variables. The number of variables that we need to keep track stays the
same.
#+END_QUOTE

#+BEGIN_QUOTE
Such a process is called a *iterative process*.
#+END_QUOTE

#+BEGIN_QUOTE
An iterative process is one whose state can be summarized by a fixed number
of state variables , together with a fixed rule
that describes how the state variables should be updated as the process
moves from state to state
#+END_QUOTE

[my understanding]
- Linear -> to compute n! we need n steps (time)
- Iterative -> to compute n! we need 1 space (memory)


**** Tail-recursive

An interpreter/compiles tail-recursive implementation executes an
 iterative process in constant space, even if the iterative process
 is described by a recursive procedure

**** exercise 1.9
#+BEGIN_SRC scheme
(define (+ a b)
(if (= a 0) b (inc (+ (dec a) b))))

(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7)
(inc 8)
;;9

(define (+ a b)
(if (= a 0) b (+ (dec a) (inc b))))

(+ 4 5)
(+ 3 6)
(+ 2 8)
(+ 1 9)
(+ 0 9)
;;9

#+END_SRC

**** exercise 1.10

#+BEGIN_SRC scheme

(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1) (A x (- y 1))))))

(A 1 10)
(A 0 (A 1 9))
(A 0 (A 0 (A 1 8))
(A 0 (A 0 .... (A 0 1))
(A 0 (A 0 ... (A 0 2))
(A 0 (A 0 .. (A 0 4)
....
2^10 = 1024

(A 2 4)
(A 1 (A 2 3))
(A 1 (A 1 (A 2 2))
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 (A 0 (A 1 1))))
(A 1 (A 1 (A 0 2)))
(A 1 (A 1 4))
(A 1 (A 0 (A 1 3)))
(A 1 (A 0 (A 0 (A 1 2))))
(A 1 (A 0 (A 0 (A 0 (A 1 1)))))
(A 1 (A 0 (A 0 (A 0 2))))
(A 1 (A 0 (A 0 4)))
(A 1 (A 0 8))
(A 1 16)
...
2^16 = 65536

(A 3 3)
(A 2 (A 3 2))
(A 2 (A 2 (A 3 1)))
(A 2 (A 2 2))
(A 2 (A 1 (A 2 1))
(A 2 (A 1 2))
(A 2 (A 0 (A 1 1)))
(A 2 (A 0 2))
(A 2 4)
...
2^16 = 65536

(define (f n) (A 0 n))   => 2*n
(define (g n) (A 1 n))   => 2^n
(define (h n) (A 2 n))   => 2^(2^n)
(define (k n) (* 5 n n)) => 5*(n^2)

#+END_SRC

[[code/clj/scr/sicp/ex1_10.clj]]

**** 1.2.2 Tree Recursion
#+BEGIN_SRC scheme
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1)) (fib (- n 2))))))

(fib 4)
(+ (fib 2) (fib 3))
(+ (+ (fib 0) (fib 1)) (+ (fib 1) (fib 2)))
(+ (+ 0 1) (+ 1 (+ (fib 0) (fib 1))))
(+ 1 (+ 1 (+ 0 1)))
(+ 1 (+ 1 1))
(+ 1 2)
;;3
#+END_SRC

#+BEGIN_QUOTE
The process uses a number of steps that grows exponentially with
the input. On the other hand, the space required grows only linearly
with the input
#+END_QUOTE

#+BEGIN_QUOTE
The number of steps required by a tree-recursive process will be
proportional to the number of nodes in the tree
#+END_QUOTE

[my understanding]
- Tree -> to compute n! we need exponential e^n steps (time)
- Recursive -> to compute n! we need n space (memory)

**** exercise 1.11
write function recursive and then iterative

[[code/clj/src/sicp/ex1_11.clj]]

**** exercise 1.12 Pascal's triangle
calculate position Pascal's triangle.

[[code/clj/src/sicp/ex1_12.clj]]

**** exercise 1.13 [someday maybe]

#+BEGIN_SRC
Prove:
fib(n) = (int) phi^n/root(5)
phi = 1 + root(5) / 2

0 1 1 2 3 5 8 13 21 34 55 89

(defn fib[n] (+ (fib (- n 2) (fib (- n 1)))))
#+END_SRC

**** 1.2.3 Orders of Growth
[[https://en.wikipedia.org/wiki/Big_O_notation][Big O Notation(wikipedia)]]
\theta (theta)

R(n) resources required

#+BEGIN_QUOTE
R(n) might measure the number of internal storage registers
used, the number of elementary machine operations performed, and so
on.
#+END_QUOTE


- Lineal recursive : Space \theta(n) Steps \theta(n)
- Lineal iterative : Space \theta(1) Steps \theta(n)
- Tree recursive : Space \theta(n) Steps \theta(\phi^n)

**** exercise 1.14

#+BEGIN_SRC scheme
(define (count-change amount)
   (cc amount 5))
(define (cc amount kinds-of-coins)
   (cond ((= amount 0) 1)
         ((or (< amount 0) (= kinds-of-coins 0)) 0)
         (else (+ (cc amount(- kinds-of-coins 1))
                  (cc (- amount (first-denomination kinds-of-coins)) kinds-of-coins)))))

(define (first-denomination kinds-of-coins)
     (cond ((= kinds-of-coins 1) 1)
           ((= kinds-of-coins 2) 5)
           ((= kinds-of-coins 3) 10)
           ((= kinds-of-coins 4) 25)
           ((= kinds-of-coins 5) 50)))


tree:

                          (count-change 11)
                               (cc 11 5)
                 (cc 11 4)   <-         ->   (cc -39 5)
         (cc 11 3)<-    -> (cc -14 4)             0
  (cc 11 2)<-  ->(cc 1 3)        0

branch:
(cc 1 3)
<- (cc 1 2)
<- (cc 1 1)
-> (cc 0 1)
1

branch:
(cc 11 2)
(cc 11 1)<- ->(cc 6 2)

branch:
(cc 6 2)
(cc 6 1)<- ->(cc 1 1)
...          ...
1            1

branch:
(cc 11 1)
(cc 10 1)
(cc 9 1)
(cc 8 1)
(cc 7 1)
(cc 6 1)
...
(cc 1 1)
(cc 0 1)
1
#+END_SRC

**** exercise 1.15

#+BEGIN_SRC scheme -n
(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine angle)
    (if (not (> (abs angle) 0.1))
         angle
         (p (sine (/ angle 3.0)))))
#+END_SRC
#+BEGIN_SRC scheme
;; a
(sine 12.5)
(p (sine 4.16))
(p (p (sine 1.39)))
(p (p (p (sine 0.46))))
(p (p (p (p (sine 0.15)))))
(p (p (p (p (p (sine 0.05))))))
(p (p (p (p (p 0.05)))))

12.5 / (3^5) = 0.049
5 times

;; b
spaces recursive O(n)

steps O(log n)
(12.5 => 5) (1000 => 10) (10000 => 12) ...
first value steps => n / (3 ^ steps) < 0.01
#+END_SRC

**** 1.2.4 Exponentiation
#+BEGIN_SRC
b^n = b * b^(n-1)

b^2 = b * b
b^4 = b^2 * b^2
...
#+END_SRC

#+BEGIN_SRC clojure -n
(defn fast-expt [b n]
  (cond (= n 0)
        1
        (even? n)
        (square (fast-expt b (/ n 2)))
        :else
        (* b (fast-expt b (dec n)))))

steps \theta(log n)
space \theta(1)
#+END_SRC

**** exercise 1.17
#+BEGIN_SRC scheme
(define (* a b)
  (if (= b 0)
      0
#+END_SRC
Linear in b \theta(n)

use double and halve to implement \theta(log n)

see clojure code: [[code/clj/src/sicp/ex1_17.clj]]

**** exercise 1.18
implement 1.17 exponential iterative

see previous code: [[code/clj/src/sicp/ex1_17.clj]]

**** 1.2.5 Greatest Common Divisor
#+BEGIN_QUOTE
The greatest common divisor (gcd) of two integers a and b is defined to
be the largest integer that divides both a and b with no remainder.

Euclid's Algorithm:
(gcd a b) is the same as (gcd b r) where r is the reminder or (/ a b)
#+END_QUOTE

#+BEGIN_SRC scheme
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
#+END_SRC

\theta(log n) & iterative

**** exercise 1.20
#calls to remainder for (gcd 206 40) in:
- normal-order of evaluation
- applicative-order of evaluation

***** applicative-order
#+BEGIN_SRC scheme
(gcd 206 40)
(gcd 40 (remainder 206 40))
(gcd 40 6)
(gcd 6 (remainder 40 6))
(gcd 6 4)
(gcd 4 (remainder 6 4))
(gcd 4 2)
(gcd 2 (reminder 4 2))
(gcd 2 0)
2
[4 remainders]

#+END_SRC

***** normal-order
#+BEGIN_SRC scheme
(gcd 206 40)
(if (= 40 0) 206 (gcd 40 (remainder 206 40))
(gcd 40 (remainder 206 40))
(if (= (remainder 206 40) 0) (remainder 206 40) (gcd (remainder 206 40) (remainder 40 (remainder 206 40))))
(gcd (remainder 206 40) (remainder 40 (remainder 206 40)))
...

total remainder evaluate 4 "if" + 4 remainders.
each remainder is evaluated for test and at the end to calculate result.
#+END_SRC

**** 1.2.6 Example: Testing for Primality

\theta(root(n)) -> divisor btw 1 and root (n)

\theta(log n) -> probabilistic algorithm (Fermat test)

Probabilistic methods/algorithms

**** exercise 1.21 [someday maybe]
#+BEGIN_SRC
(define (smallest-divisor n) (find-divisor n 2))

(define (find-divisor n test-divisor)
     (cond ((> (square test-divisor) n) n)
           ((divides? test-divisor n) test-divisor)
           (else (find-divisor n (+ test-divisor 1)))))

(define (divides? a b) (= (remainder b a) 0))

#+END_SRC
smallest-divisor of 199,1999,19999?

**** exercise 1.27 [someday maybe]
Prove (run test) Carmichael numbers fool the Fermat test.
**** exercise 1.28 [someday maybe]
Write Miller-Rabin test (Fermat test variation that can't be fooled)

*** 1.3 Formulating Abstractions with Higher-Order Procedures
- procedures: abstractions that describe compound operations on parameters
#+BEGIN_QUOTE
build abstractions by assigning names to common patterns and then to work
in terms of the abstractions directly
#+END_QUOTE
#+BEGIN_QUOTE
Procedures that
manipulate procedures are called higher-order procedures .
#+END_QUOTE
**** 1.3.1 Procedures as Arguments
#+BEGIN_QUOTE
The presence of such a common pattern is strong evidence that there is
a useful abstraction waiting to be brought to the surface.
#+END_QUOTE
#+BEGIN_SRC scheme
;;summation of a series
(define (sum term a next b)
    (if (> a b)
        (+ (term a)
        (sum term (next a) next b))))
#+END_SRC
**** 1.3.2 Contructing Procedures Using lambda \lambda
***** Using *let* to create local variables
**** 1.3.3 Procedures as General Methods
**** 1.3.4 Procedures as Returned Values
